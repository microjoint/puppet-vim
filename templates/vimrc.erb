" Modeline and notes {
" vim: set sw=4 sts=4 et tw=78 foldmarker={,} foldlevel=0 foldmethod=marker nospell:
"
" This is my .vimrc, combining varios ideas from around the internet

" Environment {
" Basics {
" Windows Compatible {
if has('win32') || has('win64')
    set runtimepath=$HOME/.vim,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after,$HOME/.vim/after
endif
" }
" Vundle {
set nocompatible               " be iMproved
filetype off                   " required!

set rtp+=<%=@config_path%>/bundle/Vundle.vim
call vundle#begin()

" let Vundle manage Vundle
" required! 
Bundle 'gmarik/vundle'

" My Bundles here:
"
" original repos on github
Bundle 'vimwiki/vimwiki'
Bundle 'MarcWeber/vim-addon-mw-utils'
Bundle 'vimoutliner/vimoutliner'
Bundle 'tpope/vim-surround'
Bundle 'scrooloose/syntastic'
Bundle 'rodjek/vim-puppet'
Bundle 'godlygeek/tabular'
Bundle 'honza/vim-snippets'
Bundle 'garbas/vim-snipmate'

" Github repos of the user 'vim-scripts'
" => can omit the username part
" Bundle 'L9'
" Bundle 'FuzzyFinder'

" non github repos
" Bundle 'git://git.wincent.com/command-t.git'
" ...

call vundle#end()

filetype plugin indent on     " required!
" }
" }
" }
" General {
set history=700				    " How much history to remember
filetype plugin on
filetype indent on              " Automatically detect file types
set mouse=a                     " automatically enable mouse usage
set mousehide                   " hide mouse cursor while typing
scriptencoding utf-8
if has ('x') && has ('gui')     " On Linux use + register for copy-paste
    set clipboard=unnamedplus
elseif has ('gui')              " On Mac and Windows, use * register for copy-paste
    set clipboard=unnamed
endif
set autowrite
set shortmess+=filmrxoOtT       " abbrev. of messages
set autoread                    " Set to auto read when a file is changed fom the outside"
au FocusLost * :wa              " Automactically save buffers when focus is lost. '..t * silent! wa' to ignore warnings
" set spell                     " spell checking on
" setlocal spell spelllang=en_us
" With a map leader it's possible to do extra key combinations
" like <leader>w saves the current file
let mapleader = ","
let g:mapleader = ","
set backspace=eol,start,indent
set whichwrap+=<,>,h,l
set ignorecase
set smartcase
" Switch to directory of the current file in active buffer
autocmd BufEnter * silent! lcd %:p:h
" }

" User Interface {
set so=3				    " Set 3 lines to the cursor when moving vertically using j/k
set wildmenu				    " Turn on wild menu
set wildignore=*.o,*~,*.pyc
set ruler
set cmdheight=2
set hidden
set relativenumber
set number
set hlsearch
set incsearch
set lazyredraw
set magic
set showmatch
set mat=2
set tabpagemax=15
set cursorline

" }

" Sound {
set noerrorbells
set novisualbell
set t_vb=
set tm=500
" }

" Colours and fonts {
syntax enable                       " Syntac highlighting
colorscheme desert256
set t_Co=256
set background=dark                 " Dark backgroud
if has("gui_running")			    " Extra GUI options
    set guioptions-=T               " Remove toolbar
    set guioptions+=c               " Use console dialogs
    set guioptions+=e               " Add tab pages when indicated
    set guioptions-=m               " Remove menu bar
    set guioptions-=r               " Remove right scrollbar
    set guitablabel=%M\ %t
endif
" }

" Files, backups {
set backup                      " Use backups
set backupdir=$HOME/.vimbackup  " location to put backups
set directory=$HOME/.vimswap    " locatoin to put swapfiles
set viewdir=$HOME/.vimviews     " location to put views
silent execute "!mkdir -p $HOME/.vimbackup"
silent execute "!mkdir -p $HOME/.vimswap"
silent execute "!mkdir -p $HOME/.vimviews"
au BufWinLeave \* silent! mkview	    " make view on save
au BufWinEnter \* silent! loadview	    " make view on save
" }

" Text, tab and indents {
set expandtab
set smarttab
set shiftwidth=4
set tabstop=4
set linebreak
set textwidth=0
set autoindent
set smartindent
set wrap
" }

" Buffers {
autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \	exe "normal! g`\"" |
    \ endif
set viminfo^=%					" Remember info about buffers
" }

" Status line {
set laststatus=2
set statusline=%t[%{strlen(&fenc)?&fenc:'none'},%{&ff}]%h%m%r%y%=%c,%l/%L\ %P
" }

" Useful mappings {
" Press <F12> to toggle paste mode
set pastetoggle=<F12>
" Press space to clear search highlighting and any message already displayed.
nnoremap <silent> <Space> :silent noh<Bar>echo<CR>
" Delete trailing whitespace on save
func! DeleteTrailingWS()
    normal mZ
    %s/\s\+$//e
    if line("'Z") != line(".")
        echo "Stripped whitespace\n"
    endif
    normal `Z
endfunc
autocmd BufWrite *.py,*.rb,*.pp :call DeleteTrailingWS()
set pastetoggle=<F12>

" quick save
map <Esc><Esc> :w<CR>

" quick indentation
nmap <Left> <<
nmap <Right> >>
vmap <Left> <gv
vmap <Right> >gv
nnoremap <Right> <C-w>l
nnoremap <Left> <C-w>h
nnoremap <Up> <C-w>k
nnoremap <Down> <C-w>j
" Insert a timestamp and turn it into a level-1 Vimwiki header
" map <F3> :r! date +"\%H:\%M:\%S"<cr>
nnoremap <F3> "=strftime("%T")<CR>P
inoremap <F3> <C-R>=strftime("%T")<CR>
" Insert date and time
" }

" Spellchecking {
map <leader>ss :setlocal spell!<cr>
map <leader>sn ]s
map <leader>sp [s
map <leader>sa zg
map <leader>sS z=

map <leader>w  w!
" Remove the Windows ^M - when the econdings get messed up
noremap <Leader>m mmHmt:$s/<C-V><cr>//ge<cr>'tzt'm
" Toggle paste mode
map <leader>pp :setlocal paste!<cr>
" Don't close window, when deleting a buffer
command! Bclose call <SID>BufcloseCloseIt()

" }

" Plugins and extensions {
" VimWiki {
let g:vimwiki_list = [{'path': '~/data/Dropbox/docs/WIKI/wiki', 'path_html': '~/data/Dropbox/docs/WIKI/html'}]
" }
" Taglist (
nnoremap <silent> <F8> :TlistToggle<CR>
let Tlist_GainFocus_On_ToggleOpen = 1
" )
" Nerdtree (
" autocmd vimenter * if !argc() | NERDTree | endif
map <C-n> :NERDTreeToggle<CR>
" )
" }

" Helper functions {
function! HasPaste()
    if $paste
	return 'PASTE MODE  '
    endif
    return ''
endfunction
function! <SID>BufcloseCloseIt()
    let l:currentBufNum = bufnr("%")
    let l:alternateBufNum = bufnr("#")
    if buflisted(l:alternateBufNum)
	buffer #
    else
	bnext
    endif
    if bufnr("%") == l:currentBufNum
	new
    endif
    if buflisted(l:currentBufNum)
	execute("bdelete! ".l:currentBufNum)
    endif
endfunction
" }
